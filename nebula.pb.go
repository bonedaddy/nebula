// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nebula.proto

package nebula

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type NebulaMeta_MessageType int32

const (
	NebulaMeta_None                   NebulaMeta_MessageType = 0
	NebulaMeta_HostQuery              NebulaMeta_MessageType = 1
	NebulaMeta_HostQueryReply         NebulaMeta_MessageType = 2
	NebulaMeta_HostUpdateNotification NebulaMeta_MessageType = 3
	NebulaMeta_HostMovedNotification  NebulaMeta_MessageType = 4
	NebulaMeta_HostPunchNotification  NebulaMeta_MessageType = 5
	NebulaMeta_HostWhoami             NebulaMeta_MessageType = 6
	NebulaMeta_HostWhoamiReply        NebulaMeta_MessageType = 7
	NebulaMeta_PathCheck              NebulaMeta_MessageType = 8
	NebulaMeta_PathCheckReply         NebulaMeta_MessageType = 9
)

var NebulaMeta_MessageType_name = map[int32]string{
	0: "None",
	1: "HostQuery",
	2: "HostQueryReply",
	3: "HostUpdateNotification",
	4: "HostMovedNotification",
	5: "HostPunchNotification",
	6: "HostWhoami",
	7: "HostWhoamiReply",
	8: "PathCheck",
	9: "PathCheckReply",
}

var NebulaMeta_MessageType_value = map[string]int32{
	"None":                   0,
	"HostQuery":              1,
	"HostQueryReply":         2,
	"HostUpdateNotification": 3,
	"HostMovedNotification":  4,
	"HostPunchNotification":  5,
	"HostWhoami":             6,
	"HostWhoamiReply":        7,
	"PathCheck":              8,
	"PathCheckReply":         9,
}

func (x NebulaMeta_MessageType) String() string {
	return proto.EnumName(NebulaMeta_MessageType_name, int32(x))
}

func (NebulaMeta_MessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{0, 0}
}

type NebulaPing_MessageType int32

const (
	NebulaPing_Ping  NebulaPing_MessageType = 0
	NebulaPing_Reply NebulaPing_MessageType = 1
)

var NebulaPing_MessageType_name = map[int32]string{
	0: "Ping",
	1: "Reply",
}

var NebulaPing_MessageType_value = map[string]int32{
	"Ping":  0,
	"Reply": 1,
}

func (x NebulaPing_MessageType) String() string {
	return proto.EnumName(NebulaPing_MessageType_name, int32(x))
}

func (NebulaPing_MessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{3, 0}
}

type NebulaMeta struct {
	Type    NebulaMeta_MessageType `protobuf:"varint,1,opt,name=Type,proto3,enum=nebula.NebulaMeta_MessageType" json:"Type,omitempty"`
	Details *NebulaMetaDetails     `protobuf:"bytes,2,opt,name=Details,proto3" json:"Details,omitempty"`
}

func (m *NebulaMeta) Reset()         { *m = NebulaMeta{} }
func (m *NebulaMeta) String() string { return proto.CompactTextString(m) }
func (*NebulaMeta) ProtoMessage()    {}
func (*NebulaMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{0}
}
func (m *NebulaMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NebulaMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NebulaMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NebulaMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NebulaMeta.Merge(m, src)
}
func (m *NebulaMeta) XXX_Size() int {
	return m.Size()
}
func (m *NebulaMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_NebulaMeta.DiscardUnknown(m)
}

var xxx_messageInfo_NebulaMeta proto.InternalMessageInfo

func (m *NebulaMeta) GetType() NebulaMeta_MessageType {
	if m != nil {
		return m.Type
	}
	return NebulaMeta_None
}

func (m *NebulaMeta) GetDetails() *NebulaMetaDetails {
	if m != nil {
		return m.Details
	}
	return nil
}

type NebulaMetaDetails struct {
	VpnIp      uint32       `protobuf:"varint,1,opt,name=VpnIp,proto3" json:"VpnIp,omitempty"`
	IpAndPorts []*IpAndPort `protobuf:"bytes,2,rep,name=IpAndPorts,proto3" json:"IpAndPorts,omitempty"`
	Counter    uint32       `protobuf:"varint,3,opt,name=counter,proto3" json:"counter,omitempty"`
}

func (m *NebulaMetaDetails) Reset()         { *m = NebulaMetaDetails{} }
func (m *NebulaMetaDetails) String() string { return proto.CompactTextString(m) }
func (*NebulaMetaDetails) ProtoMessage()    {}
func (*NebulaMetaDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{1}
}
func (m *NebulaMetaDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NebulaMetaDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NebulaMetaDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NebulaMetaDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NebulaMetaDetails.Merge(m, src)
}
func (m *NebulaMetaDetails) XXX_Size() int {
	return m.Size()
}
func (m *NebulaMetaDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_NebulaMetaDetails.DiscardUnknown(m)
}

var xxx_messageInfo_NebulaMetaDetails proto.InternalMessageInfo

func (m *NebulaMetaDetails) GetVpnIp() uint32 {
	if m != nil {
		return m.VpnIp
	}
	return 0
}

func (m *NebulaMetaDetails) GetIpAndPorts() []*IpAndPort {
	if m != nil {
		return m.IpAndPorts
	}
	return nil
}

func (m *NebulaMetaDetails) GetCounter() uint32 {
	if m != nil {
		return m.Counter
	}
	return 0
}

type IpAndPort struct {
	Ip   uint32 `protobuf:"varint,1,opt,name=Ip,proto3" json:"Ip,omitempty"`
	Port uint32 `protobuf:"varint,2,opt,name=Port,proto3" json:"Port,omitempty"`
}

func (m *IpAndPort) Reset()         { *m = IpAndPort{} }
func (m *IpAndPort) String() string { return proto.CompactTextString(m) }
func (*IpAndPort) ProtoMessage()    {}
func (*IpAndPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{2}
}
func (m *IpAndPort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpAndPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IpAndPort.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IpAndPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpAndPort.Merge(m, src)
}
func (m *IpAndPort) XXX_Size() int {
	return m.Size()
}
func (m *IpAndPort) XXX_DiscardUnknown() {
	xxx_messageInfo_IpAndPort.DiscardUnknown(m)
}

var xxx_messageInfo_IpAndPort proto.InternalMessageInfo

func (m *IpAndPort) GetIp() uint32 {
	if m != nil {
		return m.Ip
	}
	return 0
}

func (m *IpAndPort) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type NebulaPing struct {
	Type NebulaPing_MessageType `protobuf:"varint,1,opt,name=Type,proto3,enum=nebula.NebulaPing_MessageType" json:"Type,omitempty"`
	Time uint64                 `protobuf:"varint,2,opt,name=Time,proto3" json:"Time,omitempty"`
}

func (m *NebulaPing) Reset()         { *m = NebulaPing{} }
func (m *NebulaPing) String() string { return proto.CompactTextString(m) }
func (*NebulaPing) ProtoMessage()    {}
func (*NebulaPing) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{3}
}
func (m *NebulaPing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NebulaPing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NebulaPing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NebulaPing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NebulaPing.Merge(m, src)
}
func (m *NebulaPing) XXX_Size() int {
	return m.Size()
}
func (m *NebulaPing) XXX_DiscardUnknown() {
	xxx_messageInfo_NebulaPing.DiscardUnknown(m)
}

var xxx_messageInfo_NebulaPing proto.InternalMessageInfo

func (m *NebulaPing) GetType() NebulaPing_MessageType {
	if m != nil {
		return m.Type
	}
	return NebulaPing_Ping
}

func (m *NebulaPing) GetTime() uint64 {
	if m != nil {
		return m.Time
	}
	return 0
}

type NebulaHandshake struct {
	Details *NebulaHandshakeDetails `protobuf:"bytes,1,opt,name=Details,proto3" json:"Details,omitempty"`
	Hmac    []byte                  `protobuf:"bytes,2,opt,name=Hmac,proto3" json:"Hmac,omitempty"`
}

func (m *NebulaHandshake) Reset()         { *m = NebulaHandshake{} }
func (m *NebulaHandshake) String() string { return proto.CompactTextString(m) }
func (*NebulaHandshake) ProtoMessage()    {}
func (*NebulaHandshake) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{4}
}
func (m *NebulaHandshake) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NebulaHandshake) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NebulaHandshake.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NebulaHandshake) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NebulaHandshake.Merge(m, src)
}
func (m *NebulaHandshake) XXX_Size() int {
	return m.Size()
}
func (m *NebulaHandshake) XXX_DiscardUnknown() {
	xxx_messageInfo_NebulaHandshake.DiscardUnknown(m)
}

var xxx_messageInfo_NebulaHandshake proto.InternalMessageInfo

func (m *NebulaHandshake) GetDetails() *NebulaHandshakeDetails {
	if m != nil {
		return m.Details
	}
	return nil
}

func (m *NebulaHandshake) GetHmac() []byte {
	if m != nil {
		return m.Hmac
	}
	return nil
}

type NebulaHandshakeDetails struct {
	Cert           []byte `protobuf:"bytes,1,opt,name=Cert,proto3" json:"Cert,omitempty"`
	InitiatorIndex uint32 `protobuf:"varint,2,opt,name=InitiatorIndex,proto3" json:"InitiatorIndex,omitempty"`
	ResponderIndex uint32 `protobuf:"varint,3,opt,name=ResponderIndex,proto3" json:"ResponderIndex,omitempty"`
	Cookie         uint64 `protobuf:"varint,4,opt,name=Cookie,proto3" json:"Cookie,omitempty"`
	Time           uint64 `protobuf:"varint,5,opt,name=Time,proto3" json:"Time,omitempty"`
}

func (m *NebulaHandshakeDetails) Reset()         { *m = NebulaHandshakeDetails{} }
func (m *NebulaHandshakeDetails) String() string { return proto.CompactTextString(m) }
func (*NebulaHandshakeDetails) ProtoMessage()    {}
func (*NebulaHandshakeDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_2d65afa7693df5ef, []int{5}
}
func (m *NebulaHandshakeDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NebulaHandshakeDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NebulaHandshakeDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NebulaHandshakeDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NebulaHandshakeDetails.Merge(m, src)
}
func (m *NebulaHandshakeDetails) XXX_Size() int {
	return m.Size()
}
func (m *NebulaHandshakeDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_NebulaHandshakeDetails.DiscardUnknown(m)
}

var xxx_messageInfo_NebulaHandshakeDetails proto.InternalMessageInfo

func (m *NebulaHandshakeDetails) GetCert() []byte {
	if m != nil {
		return m.Cert
	}
	return nil
}

func (m *NebulaHandshakeDetails) GetInitiatorIndex() uint32 {
	if m != nil {
		return m.InitiatorIndex
	}
	return 0
}

func (m *NebulaHandshakeDetails) GetResponderIndex() uint32 {
	if m != nil {
		return m.ResponderIndex
	}
	return 0
}

func (m *NebulaHandshakeDetails) GetCookie() uint64 {
	if m != nil {
		return m.Cookie
	}
	return 0
}

func (m *NebulaHandshakeDetails) GetTime() uint64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func init() {
	proto.RegisterEnum("nebula.NebulaMeta_MessageType", NebulaMeta_MessageType_name, NebulaMeta_MessageType_value)
	proto.RegisterEnum("nebula.NebulaPing_MessageType", NebulaPing_MessageType_name, NebulaPing_MessageType_value)
	proto.RegisterType((*NebulaMeta)(nil), "nebula.NebulaMeta")
	proto.RegisterType((*NebulaMetaDetails)(nil), "nebula.NebulaMetaDetails")
	proto.RegisterType((*IpAndPort)(nil), "nebula.IpAndPort")
	proto.RegisterType((*NebulaPing)(nil), "nebula.NebulaPing")
	proto.RegisterType((*NebulaHandshake)(nil), "nebula.NebulaHandshake")
	proto.RegisterType((*NebulaHandshakeDetails)(nil), "nebula.NebulaHandshakeDetails")
}

func init() { proto.RegisterFile("nebula.proto", fileDescriptor_2d65afa7693df5ef) }

var fileDescriptor_2d65afa7693df5ef = []byte{
	// 506 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x93, 0xbf, 0x72, 0xda, 0x40,
	0x10, 0xc6, 0x39, 0x10, 0x60, 0x96, 0x3f, 0x96, 0x37, 0x09, 0x23, 0xa7, 0xd0, 0x78, 0x54, 0x64,
	0xa8, 0xc8, 0x04, 0x37, 0x69, 0x13, 0x52, 0x40, 0x01, 0x43, 0x34, 0x4e, 0x52, 0x66, 0xce, 0x68,
	0x63, 0x34, 0xc0, 0x9d, 0x46, 0x3a, 0x3c, 0xe6, 0x2d, 0xf2, 0x18, 0x79, 0x94, 0x14, 0x29, 0x5c,
	0xa4, 0x48, 0x99, 0x81, 0x17, 0xc9, 0xdc, 0x09, 0x09, 0x1b, 0x3c, 0xe9, 0xf6, 0xbb, 0xfd, 0xed,
	0xde, 0xea, 0xdb, 0x13, 0x34, 0x04, 0x5d, 0xaf, 0x16, 0xbc, 0x1b, 0xc5, 0x52, 0x49, 0xac, 0xa4,
	0xca, 0xfb, 0x55, 0x04, 0x18, 0x9b, 0x70, 0x44, 0x8a, 0x63, 0x0f, 0xac, 0xab, 0x75, 0x44, 0x0e,
	0xbb, 0x60, 0x9d, 0x56, 0xcf, 0xed, 0xee, 0x6a, 0xf6, 0x44, 0x77, 0x44, 0x49, 0xc2, 0x6f, 0x48,
	0x53, 0xbe, 0x61, 0xf1, 0x12, 0xaa, 0x1f, 0x48, 0xf1, 0x70, 0x91, 0x38, 0xc5, 0x0b, 0xd6, 0xa9,
	0xf7, 0xce, 0x8f, 0xcb, 0x76, 0x80, 0x9f, 0x91, 0xde, 0x6f, 0x06, 0xf5, 0x07, 0xad, 0xf0, 0x04,
	0xac, 0xb1, 0x14, 0x64, 0x17, 0xb0, 0x09, 0xb5, 0x81, 0x4c, 0xd4, 0xc7, 0x15, 0xc5, 0x6b, 0x9b,
	0x21, 0x42, 0x2b, 0x97, 0x3e, 0x45, 0x8b, 0xb5, 0x5d, 0xc4, 0x97, 0xd0, 0xd6, 0x67, 0x9f, 0xa2,
	0x80, 0x2b, 0x1a, 0x4b, 0x15, 0x7e, 0x0b, 0xa7, 0x5c, 0x85, 0x52, 0xd8, 0x25, 0x3c, 0x87, 0x17,
	0x3a, 0x37, 0x92, 0xb7, 0x14, 0x3c, 0x4a, 0x59, 0x59, 0x6a, 0xb2, 0x12, 0xd3, 0xd9, 0xa3, 0x54,
	0x19, 0x5b, 0x00, 0x3a, 0xf5, 0x65, 0x26, 0xf9, 0x32, 0xb4, 0x2b, 0xf8, 0x0c, 0x4e, 0xf7, 0x3a,
	0xbd, 0xb6, 0xaa, 0x27, 0x9b, 0x70, 0x35, 0xeb, 0xcf, 0x68, 0x3a, 0xb7, 0x4f, 0xf4, 0x64, 0xb9,
	0x4c, 0x91, 0x9a, 0x77, 0x0b, 0x67, 0x47, 0x1f, 0x8d, 0xcf, 0xa1, 0xfc, 0x39, 0x12, 0xc3, 0xc8,
	0xb8, 0xda, 0xf4, 0x53, 0x81, 0x6f, 0x00, 0x86, 0xd1, 0x3b, 0x11, 0x4c, 0x64, 0xac, 0xb4, 0x73,
	0xa5, 0x4e, 0xbd, 0x77, 0x96, 0x39, 0x97, 0x67, 0xfc, 0x07, 0x10, 0x3a, 0x50, 0x9d, 0xca, 0x95,
	0x50, 0x14, 0x3b, 0x25, 0xd3, 0x2a, 0x93, 0xde, 0x6b, 0xa8, 0xe5, 0x1c, 0xb6, 0xa0, 0x98, 0x5f,
	0x56, 0x1c, 0x46, 0x88, 0x60, 0xe9, 0x73, 0xb3, 0x9d, 0xa6, 0x6f, 0x62, 0xef, 0x2e, 0x5b, 0xfb,
	0x24, 0x14, 0x37, 0xff, 0x5f, 0xbb, 0x26, 0x9e, 0x58, 0x3b, 0x82, 0x75, 0x15, 0x2e, 0xc9, 0x74,
	0xb5, 0x7c, 0x13, 0x7b, 0xde, 0xd1, 0x52, 0x75, 0xb1, 0x5d, 0xc0, 0x1a, 0x94, 0x53, 0x8b, 0x98,
	0xf7, 0x15, 0x4e, 0xd3, 0xbe, 0x03, 0x2e, 0x82, 0x64, 0xc6, 0xe7, 0x84, 0x6f, 0xf7, 0x2f, 0x88,
	0x99, 0x17, 0x74, 0x30, 0x41, 0x4e, 0x1e, 0x3e, 0x23, 0x3d, 0xc4, 0x60, 0xc9, 0xa7, 0x66, 0x88,
	0x86, 0x6f, 0x62, 0xef, 0x07, 0x83, 0xf6, 0xd3, 0x75, 0x1a, 0xef, 0x53, 0xac, 0xcc, 0x2d, 0x0d,
	0xdf, 0xc4, 0xf8, 0x0a, 0x5a, 0x43, 0x11, 0xaa, 0x90, 0x2b, 0x19, 0x0f, 0x45, 0x40, 0x77, 0x3b,
	0x9f, 0x0e, 0x4e, 0x35, 0xe7, 0x53, 0x12, 0x49, 0x11, 0xd0, 0x8e, 0x4b, 0x77, 0x70, 0x70, 0x8a,
	0x6d, 0xa8, 0xf4, 0xa5, 0x9c, 0x87, 0xe4, 0x58, 0xc6, 0x99, 0x9d, 0xca, 0xfd, 0x2a, 0xef, 0xfd,
	0x7a, 0xef, 0xfc, 0xdc, 0xb8, 0xec, 0x7e, 0xe3, 0xb2, 0xbf, 0x1b, 0x97, 0x7d, 0xdf, 0xba, 0x85,
	0xfb, 0xad, 0x5b, 0xf8, 0xb3, 0x75, 0x0b, 0xd7, 0x15, 0xf3, 0x9b, 0x5e, 0xfe, 0x0b, 0x00, 0x00,
	0xff, 0xff, 0xae, 0x1a, 0x48, 0x85, 0xb6, 0x03, 0x00, 0x00,
}

func (m *NebulaMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NebulaMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NebulaMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Details != nil {
		{
			size, err := m.Details.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNebula(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NebulaMetaDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NebulaMetaDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NebulaMetaDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Counter != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Counter))
		i--
		dAtA[i] = 0x18
	}
	if len(m.IpAndPorts) > 0 {
		for iNdEx := len(m.IpAndPorts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IpAndPorts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintNebula(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.VpnIp != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.VpnIp))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IpAndPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpAndPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpAndPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Port != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x10
	}
	if m.Ip != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Ip))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NebulaPing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NebulaPing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NebulaPing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x10
	}
	if m.Type != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NebulaHandshake) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NebulaHandshake) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NebulaHandshake) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Hmac) > 0 {
		i -= len(m.Hmac)
		copy(dAtA[i:], m.Hmac)
		i = encodeVarintNebula(dAtA, i, uint64(len(m.Hmac)))
		i--
		dAtA[i] = 0x12
	}
	if m.Details != nil {
		{
			size, err := m.Details.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintNebula(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NebulaHandshakeDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NebulaHandshakeDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NebulaHandshakeDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Time != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Time))
		i--
		dAtA[i] = 0x28
	}
	if m.Cookie != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.Cookie))
		i--
		dAtA[i] = 0x20
	}
	if m.ResponderIndex != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.ResponderIndex))
		i--
		dAtA[i] = 0x18
	}
	if m.InitiatorIndex != 0 {
		i = encodeVarintNebula(dAtA, i, uint64(m.InitiatorIndex))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Cert) > 0 {
		i -= len(m.Cert)
		copy(dAtA[i:], m.Cert)
		i = encodeVarintNebula(dAtA, i, uint64(len(m.Cert)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintNebula(dAtA []byte, offset int, v uint64) int {
	offset -= sovNebula(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *NebulaMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovNebula(uint64(m.Type))
	}
	if m.Details != nil {
		l = m.Details.Size()
		n += 1 + l + sovNebula(uint64(l))
	}
	return n
}

func (m *NebulaMetaDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VpnIp != 0 {
		n += 1 + sovNebula(uint64(m.VpnIp))
	}
	if len(m.IpAndPorts) > 0 {
		for _, e := range m.IpAndPorts {
			l = e.Size()
			n += 1 + l + sovNebula(uint64(l))
		}
	}
	if m.Counter != 0 {
		n += 1 + sovNebula(uint64(m.Counter))
	}
	return n
}

func (m *IpAndPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ip != 0 {
		n += 1 + sovNebula(uint64(m.Ip))
	}
	if m.Port != 0 {
		n += 1 + sovNebula(uint64(m.Port))
	}
	return n
}

func (m *NebulaPing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovNebula(uint64(m.Type))
	}
	if m.Time != 0 {
		n += 1 + sovNebula(uint64(m.Time))
	}
	return n
}

func (m *NebulaHandshake) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Details != nil {
		l = m.Details.Size()
		n += 1 + l + sovNebula(uint64(l))
	}
	l = len(m.Hmac)
	if l > 0 {
		n += 1 + l + sovNebula(uint64(l))
	}
	return n
}

func (m *NebulaHandshakeDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Cert)
	if l > 0 {
		n += 1 + l + sovNebula(uint64(l))
	}
	if m.InitiatorIndex != 0 {
		n += 1 + sovNebula(uint64(m.InitiatorIndex))
	}
	if m.ResponderIndex != 0 {
		n += 1 + sovNebula(uint64(m.ResponderIndex))
	}
	if m.Cookie != 0 {
		n += 1 + sovNebula(uint64(m.Cookie))
	}
	if m.Time != 0 {
		n += 1 + sovNebula(uint64(m.Time))
	}
	return n
}

func sovNebula(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozNebula(x uint64) (n int) {
	return sovNebula(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NebulaMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NebulaMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NebulaMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= NebulaMeta_MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Details == nil {
				m.Details = &NebulaMetaDetails{}
			}
			if err := m.Details.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NebulaMetaDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NebulaMetaDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NebulaMetaDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VpnIp", wireType)
			}
			m.VpnIp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VpnIp |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpAndPorts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpAndPorts = append(m.IpAndPorts, &IpAndPort{})
			if err := m.IpAndPorts[len(m.IpAndPorts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Counter", wireType)
			}
			m.Counter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Counter |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpAndPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpAndPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpAndPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			m.Ip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ip |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NebulaPing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NebulaPing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NebulaPing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= NebulaPing_MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NebulaHandshake) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NebulaHandshake: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NebulaHandshake: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Details == nil {
				m.Details = &NebulaHandshakeDetails{}
			}
			if err := m.Details.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hmac", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hmac = append(m.Hmac[:0], dAtA[iNdEx:postIndex]...)
			if m.Hmac == nil {
				m.Hmac = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NebulaHandshakeDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NebulaHandshakeDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NebulaHandshakeDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cert", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNebula
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthNebula
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cert = append(m.Cert[:0], dAtA[iNdEx:postIndex]...)
			if m.Cert == nil {
				m.Cert = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorIndex", wireType)
			}
			m.InitiatorIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitiatorIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponderIndex", wireType)
			}
			m.ResponderIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponderIndex |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cookie", wireType)
			}
			m.Cookie = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cookie |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			m.Time = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Time |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNebula(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthNebula
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNebula(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNebula
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNebula
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthNebula
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupNebula
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthNebula
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthNebula        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNebula          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupNebula = fmt.Errorf("proto: unexpected end of group")
)
